goos <- function(y,X,P,Window=c("recursive","rolling"),Break=FALSE,tau=0, fig=FALSE){
  
  # Input:
  # y: the dependent variable
  # X: the matrix of predictors
  # P: the size of the evaluation sample
  # Window: recursive window or rolling window
  # Break: logic, indicate if there is a detected break in the prediction sample
  # tau: break fraction relative to the prediction sample, i.e., tau = break date / R
  # fig: logic, plot of OOS forecasts and realizations
  
  # Output:
  # Forecast: OOS forecast series
  # SSE: OOS forecast errors
  # Beta: sequence of parameter estimates based on OLS
  # SSE: sequence of sum of squared residuals
  # MSFE: OOS mean squared forecast error
  # RMSFE: square root of OOS mean squared forecast error
  # LAMBDA: sequence of trace values needed to calculate CV weights
  
  # Note:
  # 1. If there is a detected break in the prediction sample, OOS forecasts are generated by using post break window. Other methods may be considered.
  # 2. Newey-West method is used in computing the "meat" of the covariance matrix for LAMBDA. 
  
  require(sandwich)
  if(missing(P)) P <- 0.2 * length(y)
  if(P >= length(y)) stop("Prediction sample larger than total sample size!")
  if(missing(Window)) Window <- "recursive"
  
  Window <- match.arg(Window)
  
  if (X == 0){
    y <- as.matrix(y)
    P <- as.numeric(P)
    tau <- as.numeric(tau)
    n <- length(y) # total sample size
    
    R <- n - P        # prediction sample size
    yr <- numeric(P)  # forecast
    sfe <- numeric(P) # squared forecast error
    fe <- numeric(P)  # forecast error
    yp <- y[(R+1):n] # evaluation sample of y
    beta.oos <- matrix(0,P,1) # sequence of OLS parameter estimates
    sse <- numeric(P) # sequence of sum of squared residuals
    lam <- numeric(P) # sequence of trace values needed to calculate CV weights
    
    
    if (Break == FALSE && Window == "recursive") {
      
      for (i in 1:P) {
        y.n <- y[1:(R+i-1)]
        Q <- R+i-1
        Qinv <- 1/Q
        reg <- lm(y.n~1)
        lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <- sum(resid(reg)^2)
        beta.oos[i] <- coef(reg)
        yr[i] <- beta.oos[i]
        fe[i] <- yp[i]-yr[i]
        sfe[i] <- (yp[i]-yr[i])^2
      }
      
      MSFE <- sum(sfe)/P
      RMSFE <- sqrt(MSFE)
      y.oos <- yr
      e.oos <- fe
      
      if (fig == TRUE) {
        plot(1:P,yp,type='l',col=4,xlab="Time",ylab="Value",main="OOS Forecast: Recursive Window")
        lines(1:P,yr,col=2,lty=2)
        legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
      
      group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
    
    if (Break == FALSE && Window == "rolling") {
      
      for (i in 1:P) {
        y.n <- y[i:(R+i-1)]
        Q <- R
        Qinv <- 1/R
        reg <- lm(y.n~1)
        lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <- sum(resid(reg)^2)
        beta.oos[i] <- coef(reg)
        yr[i] <- beta.oos[i]
        fe[i] <- yp[i]-yr[i]
        sfe[i] <- (yp[i]-yr[i])^2
      }
      
      MSFE<-sum(sfe)/P
      RMSFE<-sqrt(MSFE)
      y.oos<-yr
      e.oos<-fe
      
      if (fig == TRUE) {
        plot(1:P,yp,col=4,type='l',xlab="Time",ylab="Value",main="OOS Forecast: Rolling Window")
        lines(1:P,yr,col=2,lty=2)
        legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
      
      group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
    
    
    if (Break == TRUE && Window == "recursive") {
      m <- floor(tau*R)+1
      y0 <- y[1:(m-1)] # prebreak sample
      sse.pre <- sum(resid(lm(y0~1))^2) # prebreak SSE
      
      for (i in 1:P) {
        y.n <- y[m:(R+i-1)]
        Q <- R+i-m
        Qinv <- 1/Q
        reg <- lm(y.n~1)
        lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <- sum(resid(reg)^2) + sse.pre
        beta.oos[i] <- coef(reg)
        yr[i] <- beta.oos[i]
        fe[i] <- yp[i]-yr[i]
        sfe[i] <- (yp[i]-yr[i])^2
      }
      
      MSFE <- sum(sfe)/P
      RMSFE <- sqrt(MSFE)
      y.oos <- yr
      e.oos <- fe
      
      if (fig == TRUE) {
        plot(1:P,yp,type='l',col=4,xlab="Time",ylab="Value",main="OOS Forecast: Recursive Window")
        lines(1:P,yr,col=2,lty=2)
        legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
      
      group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
    
    if (Break == TRUE && Window == "rolling") {
      m <- floor(tau*R)+1
      y0 <- y[1:(m-1)]
      sse.pre <- sum(resid(lm(y0~1))^2)
      for (i in 1:P) {
        y.n <- y[(m+i-1):(R+i-1)]
        Q <- R-m+1
        Qinv <- 1/Q
        reg <- lm(y.n~1)
        lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <- sum(resid(reg)^2)+sse.pre
        beta.oos[i] <- coef(reg)
        yr[i] <- beta.oos[i]
        fe[i] <- yp[i]-yr[i]
        sfe[i] <- (yp[i]-yr[i])^2
      }
      
      MSFE<-sum(sfe)/P
      RMSFE<-sqrt(MSFE)
      y.oos<-yr
      e.oos<-fe
      
      if (fig == TRUE) {
        plot(1:P,yp,col=4,type='l',xlab="Time",ylab="Value",main="OOS Forecast: Rolling Window")
        lines(1:P,yr,col=2,lty=2)
        legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
      
      group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
  }
  
  y <- as.matrix(y)
  X <- as.matrix(X)
  P <- as.numeric(P)
  tau <- as.numeric(tau)
  
  n <- length(y) # total sample size
  nreg <- ncol(X) # number of regressors
  X <- cbind(rep(1,n),X) # design matrix including the constant term
  num <- ncol(X) # number of column
  
  R <- n - P        # prediction sample size
  yr <- numeric(P)  # forecast
  sfe <- numeric(P) # squared forecast error
  fe <- numeric(P)  # forecast error
  Xp <- X[(R+1):n,] # evaluation sample of X
  yp <- y[(R+1):n] # evaluation sample of y
  beta.oos <- matrix(0,P,nreg+1) # sequence of OLS parameter estimates
  sse <- numeric(P) # sequence of sum of squared residuals
  lam <- numeric(P) # sequence of trace values needed to calculate CV weights
  
  
  if (Break == FALSE && Window == "recursive") {
    
    for (i in 1:P) {
      y.n <- y[1:(R+i-1)]
      x1.n <- X[1:(R+i-1),2:num]
      Q <- t(X[1:(R+i-1),])%*%X[1:(R+i-1),]
      Qinv <- solve(Q)
      reg <- lm(y.n~x1.n)
      lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
      sse[i] <- sum(resid(reg)^2)
      beta.oos[i,] <- coef(reg)
      yr[i] <- Xp[i,]%*%coef(reg)
      fe[i] <- yp[i]-yr[i]
      sfe[i] <- (yp[i]-yr[i])^2
    }
    
    MSFE <- sum(sfe)/P
    RMSFE <- sqrt(MSFE)
    y.oos <- yr
    e.oos <- fe
    
    if (fig == TRUE) {
      plot(1:P,yp,type='l',col=4,xlab="Time",ylab="Value",main="OOS Forecast: Recursive Window")
      lines(1:P,yr,col=2,lty=2)
      legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
    
    group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
  }
  
  if (Break == FALSE && Window == "rolling") {
    
    for (i in 1:P) {
      y.n <- y[i:(R+i-1)]
      x1.n <- X[i:(R+i-1),2:num]
      Q <- t(X[i:(R+i-1),])%*%X[i:(R+i-1),]
      Qinv <- solve(Q)
      reg <- lm(y.n~x1.n)
      lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
      sse[i] <- sum(resid(reg)^2)
      beta.oos[i,] <- coef(reg)
      yr[i] <- Xp[i,]%*%coef(reg)
      fe[i] <- yp[i]-yr[i]
      sfe[i] <- (yp[i]-yr[i])^2
    }
    
    MSFE<-sum(sfe)/P
    RMSFE<-sqrt(MSFE)
    y.oos<-yr
    e.oos<-fe
    
    if (fig == TRUE) {
      plot(1:P,yp,col=4,type='l',xlab="Time",ylab="Value",main="OOS Forecast: Rolling Window")
      lines(1:P,yr,col=2,lty=2)
      legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
    
    group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
  }
  
  
  if (Break == TRUE && Window == "recursive") {
    m <- floor(tau*R)+1
    y0 <- y[1:(m-1)] # prebreak sample
    x10 <- X[1:(m-1),2:num] #prebreak sample
    sse.pre <- sum(resid(lm(y0~x10))^2) # prebreak SSE
    
    for (i in 1:P) {
      y.n <- y[m:(R+i-1)]
      x1.n <- X[m:(R+i-1),2:num]
      Q <- t(X[m:(R+i-1),])%*%X[m:(R+i-1),]
      Qinv <- solve(Q)
      reg <- lm(y.n~x1.n)
      lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
      sse[i] <- sum(resid(reg)^2) + sse.pre
      beta.oos[i,] <- coef(reg)
      yr[i] <- Xp[i,]%*%coef(reg)
      fe[i] <- yp[i]-yr[i]
      sfe[i] <- (yp[i]-yr[i])^2
    }
    
    MSFE <- sum(sfe)/P
    RMSFE <- sqrt(MSFE)
    y.oos <- yr
    e.oos <- fe
    
    if (fig == TRUE) {
      plot(1:P,yp,type='l',col=4,xlab="Time",ylab="Value",main="OOS Forecast: Recursive Window")
      lines(1:P,yr,col=2,lty=2)
      legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
    
    group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
  }
  
  if (Break == TRUE && Window == "rolling") {
    m <- floor(tau*R)+1
    y0 <- y[1:(m-1)]
    x10 <- X[1:(m-1),2:num]
    sse.pre <- sum(resid(lm(y0~x10))^2)
    for (i in 1:P) {
      y.n <- y[(m+i-1):(R+i-1)]
      x1.n <- X[(m+i-1):(R+i-1),2:num]
      Q <- t(X[(m+i-1):(R+i-1),])%*%X[(m+i-1):(R+i-1),]
      Qinv <- solve(Q)
      reg <- lm(y.n~x1.n)
      lam[i] <- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
      sse[i] <- sum(resid(reg)^2)+sse.pre
      beta.oos[i,] <- coef(reg)
      yr[i] <- Xp[i,]%*%coef(reg)
      fe[i] <- yp[i]-yr[i]
      sfe[i] <- (yp[i]-yr[i])^2
    }
    
    MSFE<-sum(sfe)/P
    RMSFE<-sqrt(MSFE)
    y.oos<-yr
    e.oos<-fe
    
    if (fig == TRUE) {
      plot(1:P,yp,col=4,type='l',xlab="Time",ylab="Value",main="OOS Forecast: Rolling Window")
      lines(1:P,yr,col=2,lty=2)
      legend("topright", c("Actual","Forecast"),lty=c(1,2),col=c(4,2))}
    
    group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
  }
  
}