goos <- function(y,X,P,Window=c("recursive","rolling"),Break=FALSE,tau=0){
  
  # Input:
  # y: the dependent variable
  # X: the matrix of predictors, set X = NULL for intercept-only model
  # P: the size of the evaluation sample
  # Window: recursive window or rolling window
  # Break: logic, indicate if there is a detected break in the prediction sample
  # tau: break fraction relative to the prediction sample, i.e., tau = break date / R
  
  # Output:
  # Forecast: OOS forecast series
  # SSE: OOS forecast errors
  # Beta: sequence of parameter estimates based on OLS
  # SSE: sequence of sum of squared residuals
  # MSFE: OOS mean squared forecast error
  # RMSFE: square root of OOS mean squared forecast error
  # LAMBDA: sequence of trace values needed to calculate CV weights
  
  # Note:
  # 1. If there is a detected break in the prediction sample, OOS forecasts are generated by using post break window. Other methods may be considered.
  # 2. Newey-West method is used in computing the "meat" of the covariance matrix for LAMBDA. 
  if(!require(sandwich)) {require(sandwich)}
  if(missing(P)) P <- 0.2 * length(y)
  if(P >= length(y)) stop("Prediction sample larger than total sample size!")
  if(missing(Window)) Window <- "recursive"
  
  Window <- match.arg(Window)
  
  if (is.null(X)){
    
	y <- as.matrix(y)
    P <- as.numeric(P)
    tau <- as.numeric(tau)
    n <- length(y) # total sample size
    
    R <- n - P        # prediction sample size
    yr <- numeric(P)  # forecast
    sfe <- numeric(P) # squared forecast error
    fe <- numeric(P)  # forecast error
    yp <- y[(R+1):n] # evaluation sample of y
    beta.oos <- matrix(0,P,1) # sequence of OLS parameter estimates
    sse <- numeric(P) # sequence of sum of squared residuals
    lam <- numeric(P) # sequence of trace values needed to calculate CV weights
    
	forecaster.recursive <- function(i){

		y.n <- y[1:(R+i-1)]
		Q <- R+i-1
        Qinv <- 1/Q
        reg <- lm(y.n~1)
        lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <<- sum(resid(reg)^2)
        beta.oos[i] <<- coef(reg)
        yr[i] <<- beta.oos[i]
        fe[i] <<- yp[i]-yr[i]
        sfe[i] <<- (yp[i]-yr[i])^2

	}
    
	forecaster.rolling <- function(i){
	
        y.n <- y[i:(R+i-1)]
        Q <- R
        Qinv <- 1/R
        reg <- lm(y.n~1)
        lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <<- sum(resid(reg)^2)
        beta.oos[i] <<- coef(reg)
        yr[i] <<- beta.oos[i]
        fe[i] <<- yp[i]-yr[i]
        sfe[i] <<- (yp[i]-yr[i])^2
		
    }
	
	forecaster.recursive.break <- function(i){

        y.n <- y[m:(R+i-1)]
        Q <- R+i-m
        Qinv <- 1/Q
        reg <- lm(y.n~1)
        lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <<- sum(resid(reg)^2) + sse.pre
        beta.oos[i] <<- coef(reg)
        yr[i] <<- beta.oos[i]
        fe[i] <<- yp[i]-yr[i]
        sfe[i] <<- (yp[i]-yr[i])^2
     
	 }
	
	forecaster.rolling.break <- function(i){

        y.n <- y[(m+i-1):(R+i-1)]
        Q <- R-m+1
        Qinv <- 1/Q
        reg <- lm(y.n~1)
        lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
        sse[i] <<- sum(resid(reg)^2)+sse.pre
        beta.oos[i] <<- coef(reg)
        yr[i] <<- beta.oos[i]
        fe[i] <<- yp[i]-yr[i]
        sfe[i] <<- (yp[i]-yr[i])^2
     
	 }
	
    if (Break == FALSE && Window == "recursive") {
      
	  invisible(unlist(lapply(1:P, forecaster.recursive)))
      
      MSFE <- sum(sfe)/P
      RMSFE <- sqrt(MSFE)
      y.oos <- yr
      e.oos <- fe
      
      group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
    
    if (Break == FALSE && Window == "rolling") {
      
      invisible(unlist(lapply(1:P, forecaster.rolling)))
      
      MSFE <- sum(sfe)/P
      RMSFE <- sqrt(MSFE)
      y.oos <- yr
      e.oos <- fe
      
      group <- list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group) <- c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
    
    
    if (Break == TRUE && Window == "recursive") {
      
	  m <- floor(tau*R)+1
      y0 <- y[1:(m-1)] # prebreak sample
      sse.pre <- sum(resid(lm(y0~1))^2) # prebreak SSE
      
      invisible(unlist(lapply(1:P, forecaster.recursive.break)))
      
      MSFE <- sum(sfe)/P
      RMSFE <- sqrt(MSFE)
      y.oos <- yr
      e.oos <- fe
      
      group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
    
    if (Break == TRUE && Window == "rolling") {
      
	  m <- floor(tau*R)+1
      y0 <- y[1:(m-1)]
      sse.pre <- sum(resid(lm(y0~1))^2)
      
	  invisible(unlist(lapply(1:P, forecaster.rolling.break)))
      
      MSFE<-sum(sfe)/P
      RMSFE<-sqrt(MSFE)
      y.oos<-yr
      e.oos<-fe
      
      group<-list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
      names(group)<-c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
      return(invisible(group))
    }
  }
  
  y <- as.matrix(y)
  X <- as.matrix(X)
  P <- as.numeric(P)
  tau <- as.numeric(tau)
  
  n <- length(y) # total sample size
  nreg <- ncol(X) # number of regressors
  X <- cbind(rep(1,n),X) # design matrix including the constant term
  num <- ncol(X) # number of column
  
  R <- n - P        # prediction sample size
  yr <- numeric(P)  # forecast
  sfe <- numeric(P) # squared forecast error
  fe <- numeric(P)  # forecast error
  Xp <- X[(R+1):n,] # evaluation sample of X
  yp <- y[(R+1):n] # evaluation sample of y
  beta.oos <- matrix(0,P,nreg+1) # sequence of OLS parameter estimates
  sse <- numeric(P) # sequence of sum of squared residuals
  lam <- numeric(P) # sequence of trace values needed to calculate CV weights
  
  forecaster.recursive <- function(i){

		  y.n <- y[1:(R+i-1)]
		  x1.n <- X[1:(R+i-1),2:num]
		  Q <- t(X[1:(R+i-1),])%*%X[1:(R+i-1),]
		  Qinv <- solve(Q)
		  reg <- lm(y.n~x1.n)
		  lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
		  sse[i] <<- sum(resid(reg)^2)
		  beta.oos[i,] <<- coef(reg)
		  yr[i] <<- Xp[i,]%*%coef(reg)
		  fe[i] <<- yp[i]-yr[i]
		  sfe[i] <<- (yp[i]-yr[i])^2

	}
    
	forecaster.rolling <- function(i){
	
		  y.n <- y[i:(R+i-1)]
		  x1.n <- X[i:(R+i-1),2:num]
		  Q <- t(X[i:(R+i-1),])%*%X[i:(R+i-1),]
		  Qinv <- solve(Q)
		  reg <- lm(y.n~x1.n)
		  lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
		  sse[i] <<- sum(resid(reg)^2)
		  beta.oos[i,] <<- coef(reg)
		  yr[i] <<- Xp[i,]%*%coef(reg)
		  fe[i] <<- yp[i]-yr[i]
		  sfe[i] <<- (yp[i]-yr[i])^2
		
    }
	
	forecaster.recursive.break <- function(i){

		  y.n <- y[m:(R+i-1)]
		  x1.n <- X[m:(R+i-1),2:num]
		  Q <- t(X[m:(R+i-1),])%*%X[m:(R+i-1),]
		  Qinv <- solve(Q)
		  reg <- lm(y.n~x1.n)
		  lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
		  sse[i] <<- sum(resid(reg)^2) + sse.pre
		  beta.oos[i,] <<- coef(reg)
		  yr[i] <<- Xp[i,]%*%coef(reg)
		  fe[i] <<- yp[i]-yr[i]
		  sfe[i] <<- (yp[i]-yr[i])^2
     
	 }
	
	forecaster.rolling.break <- function(i){

		  y.n <- y[(m+i-1):(R+i-1)]
		  x1.n <- X[(m+i-1):(R+i-1),2:num]
		  Q <- t(X[(m+i-1):(R+i-1),])%*%X[(m+i-1):(R+i-1),]
		  Qinv <- solve(Q)
		  reg <- lm(y.n~x1.n)
		  lam[i] <<- sum(diag(Qinv%*%NeweyWest(reg,sandwich=FALSE,prewhite = FALSE)))
		  sse[i] <<- sum(resid(reg)^2)+sse.pre
		  beta.oos[i,] <<- coef(reg)
		  yr[i] <<- Xp[i,]%*%coef(reg)
		  fe[i] <<- yp[i]-yr[i]
		  sfe[i] <<- (yp[i]-yr[i])^2
     
	 }
  
  
  if (Break == FALSE && Window == "recursive") {
    
    invisible(unlist(lapply(1:P, forecaster.recursive)))
    
    MSFE <- sum(sfe)/P
    RMSFE <- sqrt(MSFE)
    y.oos <- yr
    e.oos <- fe
    
    group <- list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group) <- c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
	
  }
  
  if (Break == FALSE && Window == "rolling") {
    
	invisible(unlist(lapply(1:P, forecaster.rolling)))
    
    MSFE <- sum(sfe)/P
    RMSFE <- sqrt(MSFE)
    y.oos <- yr
    e.oos <- fe
    
    group <- list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group) <- c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
	
  }
  
  
  if (Break == TRUE && Window == "recursive") {
    
	m <- floor(tau*R)+1
    y0 <- y[1:(m-1)] # prebreak sample
    x10 <- X[1:(m-1),2:num] #prebreak sample
    sse.pre <- sum(resid(lm(y0~x10))^2) # prebreak SSE
    
    invisible(unlist(lapply(1:P, forecaster.recursive.break)))
    
    MSFE <- sum(sfe)/P
    RMSFE <- sqrt(MSFE)
    y.oos <- yr
    e.oos <- fe
    
    group <- list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group) <- c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
  }
  
  if (Break == TRUE && Window == "rolling") {
    
	m <- floor(tau*R)+1
    y0 <- y[1:(m-1)]
    x10 <- X[1:(m-1),2:num]
    sse.pre <- sum(resid(lm(y0~x10))^2)
    
	invisible(unlist(lapply(1:P, forecaster.rolling.break)))
    
    MSFE <- sum(sfe)/P
    RMSFE <- sqrt(MSFE)
    y.oos <- yr
    e.oos <- fe
    
    group <- list(y.oos,e.oos,beta.oos,sse,MSFE,RMSFE,lam,sfe)
    names(group) <- c("Forecast","Error","Beta","SSE","MSFE","RMSFE","LAMBDA","SFE")
    return(invisible(group))
  }
  
}